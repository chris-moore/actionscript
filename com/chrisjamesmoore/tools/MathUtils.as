package com.chrisjamesmoore.tools {	import flash.geom.Point;		/**	 *	[MathUtils]	 * 	 *	@author			Chris Moore	 *	@version		1.0.2	 *	@date			Sep 20, 2012	 *	@client					 *	@project	 *	@producer	 *	@langversion	ActionScript 3.0	 *	@playerversion	Flash Player 10	 *	 *  @history 1.0.3 (2012.09.20) Ported class to com.chrisjamesmoore package for github repository.	 *	@history 1.0.2 (May 24, 2011) Added archived methods from NumberUtils AS2 class	 *	@history 1.0.1 (Nov 19, 2009) Refactored for AS3 Framework	 *	@history 1.0.0 (Feb 11, 2008) Created initial version of MathUtils for AS3.	 */	public class MathUtils {			//--------------------------------------------------		// PUBLIC STATIC PROPERTIES		//--------------------------------------------------				/**		 *	The fully qualifed class name and path. This can be accessed from the class but the value		 * 	can also be retrieved from the instance using the getter fullyQualifedClassPath		 */		public static var FULLY_QUALIFIED_CLASS_PATH: String = "com.chrisjamesmoore.tools.MathUtils";				//--------------------------------------------------		// PRIVATE STATIC PROPERTIES		//--------------------------------------------------				//--------------------------------------------------		// PUBLIC PROPERTIES		//--------------------------------------------------				//--------------------------------------------------		// PRIVATE PROPERTIES		//--------------------------------------------------				//--------------------------------------------------		// CONSTRUCTOR		//--------------------------------------------------				/**		 *  Private empty constructor. This class should not be instantiated.		 */		public function MathUtils() {}				//--------------------------------------------------		// GETTERS / SETTERS		//--------------------------------------------------				//--------------------------------------------------		// EVENT HANDLERS		//--------------------------------------------------				//--------------------------------------------------		// PUBLIC METHODS		//--------------------------------------------------				/**		 * Converts an angular velocity (or acceleration) vector to a coordinate vector.		 * @param	force	(Number) The speed or acceleration to calculate.		 * @param	angle	(Number) The angle in radians.		 * @return			(Point) A two-value array with the xVector and yVector (like x velocity and y velocity or x acceleration and y acceleration).		 */		public static function angleToCoord(force:Number, angle:Number):Point 		{			return new Point(force * Math.cos(angle), force * Math.sin(angle));		}				/**		 * Returns a random number between min and max.		 * @param	min		(Number) 		 * @param 	max		(Number)		 * @return	Number		 */		public static function randomRange(min:Number, max:Number):Number 		{		    var randomNum:Number = (Math.random() * (max - min)) + min;		    return randomNum;		}				/**		 * Returns a number between min and max.		 * @param 	num		(Number) Target number for manipulation		 * @param	min		(Number) 		 * @param 	max		(Number)		 * @return	Number		 */		public static function withinRange(num:Number, min:Number, max:Number):Number 		{			if(num < min) { num = min; }			if(num > max) { num = max; }			return num;		}				/**		 * Returns a number of rotation from one point to another.		 * @param	ax		(Number) 		 * @param 	ay		(Number)		 * @param 	bx		(Number)		 * @param 	by		(Number)		 * @return	int		 */		public static function directionalRotation(ax:Number, ay:Number, bx:Number, by:Number):int 		{		    var angle:Number = 0;						var adjside:Number = ax-bx;			var oppside:Number = -1*(ay-by);						angle = Math.atan2(oppside, adjside); // in radians			angle = Math.round(angle/Math.PI*180)-90; // convert to degrees						return -1*(angle);		}				/**		 * Returns a comma formatted number.		 * @param	number		(Number) The number to be formatted		 * @return	String		 */		public static function commaFormat(number:Number):String		{		        var numString:String = number.toString();		        var result:String = '';				        while (numString.length > 3)		        {		                var chunk:String = numString.substr(-3);		                numString = numString.substr(0, numString.length - 3);		                result = ',' + chunk + result;		        }				        if (numString.length > 0)		        {		                result = numString + result;		        }				        return result;		}				/**		 *	Returns a string formatted for time		 *	@param time (Number)		 *	@return	void		 */		public static function getTimecode(time:Number):String 		{			var t:Number = Math.round(time);			var min:Number = Math.floor(t/60);			var sec:Number = t%60;			var tc:String = new String("");						if(min < 10) {				tc += "0";			}						if(min >= 1) {				tc += min.toString();			} else {				tc += "0";			}						tc += ":";						if(sec < 10) {				tc += "0";				tc += sec.toString();			} else {				tc += sec.toString();			}						return tc;		}					/**		 * Returns the length of a hypotenuse of a right triangle.		 * @param	length		(Number) 		 * @return	Number		 */		public static function getHypotenuse(a:Number, b:Number):Number 		{		    var length:Number =  Math.sqrt((a*a)+(b*b));		    			return length;		}				/**		 * Converts a decimal number to hexadecimal format.		 * @param	n		(Number) The number in decimal format.		 * @return			(String) A string representation of the number in hexadecimal format.		 */		public static function decToHex(n:Number):String		{			return "0x"+n.toString(16);		}				/**		 * Converts a hexidecimal number in Number or String format to a decimal number.		 * @param	n		(Object) The number in hexidecimal format as a String or Number.		 * @return			(Number) The the number in decimal format.		 */		public static function hexToDec(n:Object):Number 		{			if (typeof(n) == "string" || typeof(n) == "number") {				return Number(n.toString());			} else {				return 0;			}		}				/**		 * Extracts the red, green, or blue component from a hexidecimal color value.		 * @param	comp	(String) either "red", "green", or "blue" for which color to extract.		 * @param	col		(Number) The original color value (usually in hexidecimal format).		 * @return			(Number) the extracted color value, in hexidecimal format with a leading "0x".		 */		public static function extractComponentColor(comp:String, col:Number):Number 		{				if (col > 0xFFFFFF || col < 0 || col % 1 != 0 || col == Infinity || col == -Infinity || isNaN(col)) {							} else {				switch (comp.toLowerCase()) {					case "red" :					return col >> 16;					break;					case "green" :					return col >> 8 & 0xFF;					break;					case "blue" :					return col & 0xFF;					break;					default :					Debugger.access().alert(" ### [" + FULLY_QUALIFIED_CLASS_PATH + ".extractComponentColor] FIRST ARGUEMENT MUST BE 'RED' 'GREEN' OR 'BLUE'", 3);					break;				}			}			return 0x000000;		}				/**		 * Evaluates whether a number is even or not.		 * @param	n		(Number) The number to evaluate.		 * @return			(Boolean) True if the number is even or 0, false if not.		 */		public static function isEven(n:Number):Boolean 		{			if (n % 2 == 0 || n == 0) {				return true;			} else {				return false;			}		}				/**		 * Evaluates whether a number is positive or not.		 * @param	n		(Number) The number to evaluate.		 * @return			(Boolean) True if the number is positive or 0, false if not.		 */		public static function isPositive(n:Number):Boolean 		{			if (n >=0) {				return true;			} else {				return false;			}		}				/**		 * Calculates the distance between two points in 2d space.		 * @param	x1		(Number) First point's x coordinate.		 * @param	y1		(Number) First point's y coordinate.		 * @param	x2		(Number) Second point's x coordinate.		 * @param	y2		(Number) Second point's y coordinate.		 * @since 1.0.0		 * @return			(Number) The distance between the two points.		 */		public static function getProximity(x1:Number, y1:Number, x2:Number, y2:Number):Number 		{			return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));		}				/**		 * Rotate a movie clip so the registration point faces a coordinate.		 * @param	mc		(MovieClip) The DisplayObject to rotate.		 * @param	xTarget	(Number) The x coordinate to aim the DisplayObject toward.		 * @param	yTarget	(Number) The y coordinate to aim the DisplayObject toward.		 * @return			(Number) The new rotation of the DisplayObject		 */		public static function rotateToPoint(x:Number, y:Number, xTarget:Number, yTarget:Number):Number 		{			return Math.atan2((yTarget - y), ( xTarget - x)) * 180 / Math.PI;		}				/**		 * Returns the coordinates of a rotation around an arbitrary point by a certain number of degrees, in radians.		 * @param	angle	(Number) The angle in degrees to rotate the MovieClip.		 * @param	centerX	(Number) The x coordinate of the center of rotation.		 * @param	centerY	(Number) The y coordinate to the center of rotation.		 * @return			(Point)  A point with the x coordinate and the y coordinate after rotation.		 */		public static function rotateAroundPoint(angle:Number, centerX:Number, centerY:Number):Point 		{			return new Point((Math.cos(angle) * centerX - Math.sin(angle) * centerY), (Math.cos(angle) * centerX - Math.sin(angle) * centerY));		}				/**		 * Supply a starting index, an amount to increment (positive or negative), and a limit on how high to count and this method will return the new index, wrapped around the end (if a positive increment) or around zero (if a negative increment).		 * @param	startIndex	(Number) The index in the array to begin counting from.		 * @param	increment	(Number) Mow many times to increment the number.		 * @param	cap			(Number) The limit of the list (when to start wrapping).		 * @return				(Number) The new number, an unsigned integer, after wrapping.		 */		public static function wrapNumber(startIndex:Number, increment:Number, cap:Number):Number 		{			var newIndex:Number;			newIndex = startIndex + increment;				if (newIndex < 0) {				newIndex = (newIndex + cap) % cap;			} else if (newIndex >= cap) {				newIndex %= cap;			}			return newIndex;		}				/**		 * Returns a number of rotation from radians into degrees.		 * @param	radians		(Number) 		 * @return	Number		 */		public static function radiansToDegrees(radians:Number):Number 		{		    var degrees:Number =  radians * 180 / Math.PI;		    			return degrees;		}				/**		 * Returns a number of rotation from degrees into radians.		 * @param	degrees		(Number) 		 * @return	Number		 */		public static function degreesToRadians(degrees:Number):Number 		{		    var radians:Number = degrees * Math.PI / 180;		    			return radians;		}	}}